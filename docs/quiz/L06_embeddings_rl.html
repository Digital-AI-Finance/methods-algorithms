<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 6: Embeddings & RL | Methods & Algorithms</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVuj4nkfMTmM/M/7EKJVGr6aSozTWXMEoxlNVlTqOgKHMJCnGZJ73Lpr/7Vdw" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Ber8i1e2fQs9/h7qJC/H6MXGLS8/3k0JzqfGJhZ" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxUvBOCaIpzhqKdQZnIJu5B6/HYJv9CrNR6xFZveLXHPmGIFV9O1e5sXD0J1c" crossorigin="anonymous"></script>
    <style>
        :root {
            --mlpurple: #3333B2;
            --mlblue: #0066CC;
            --quiz-accent: #8b5cf6;
            --quiz-light: #ede9fe;
            --correct: #22c55e;
            --correct-bg: #dcfce7;
            --incorrect: #ef4444;
            --incorrect-bg: #fee2e2;
            --bg: #f6f8fa;
            --card-bg: #ffffff;
            --text: #24292e;
            --text-secondary: #586069;
            --border: #e1e4e8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.4;
            min-height: 100vh;
        }

        .nav {
            background: linear-gradient(135deg, var(--mlpurple), var(--mlblue));
            color: white;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nav-title { font-weight: 600; font-size: 14px; }
        .nav-links { display: flex; gap: 16px; }
        .nav-links a { color: white; text-decoration: none; font-size: 12px; opacity: 0.9; }
        .nav-links a:hover { opacity: 1; }

        .quiz-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        .quiz-title { font-size: 16px; font-weight: 600; color: var(--mlpurple); }
        .quiz-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .stat-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .stat-progress { background: var(--quiz-light); color: var(--quiz-accent); }
        .stat-score { background: var(--correct-bg); color: var(--correct); }

        .progress-bar-container {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 12px;
        }
        .progress-bar {
            height: 100%;
            background: var(--quiz-accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Three-column layout */
        .questions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 280px;
        }

        .question-card.answered { opacity: 0.7; }

        .question-card.correct-card {
            border: 2px solid var(--correct);
            background: linear-gradient(to bottom, var(--correct-bg), var(--card-bg));
        }

        .question-card.incorrect-card {
            border: 2px solid var(--incorrect);
            background: linear-gradient(to bottom, var(--incorrect-bg), var(--card-bg));
        }

        .q-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .q-number {
            background: var(--quiz-light);
            color: var(--quiz-accent);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .q-status { font-size: 14px; }

        .q-text {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 10px;
            line-height: 1.4;
            flex-grow: 0;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-grow: 1;
        }

        .option-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            min-height: 44px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-size: 12px;
        }

        .option-btn:hover:not(.disabled) {
            border-color: var(--quiz-accent);
            background: var(--quiz-light);
        }

        .option-btn.correct {
            border-color: var(--correct);
            background: var(--correct-bg);
        }

        .option-btn.incorrect {
            border-color: var(--incorrect);
            background: var(--incorrect-bg);
        }

        .option-btn.disabled { cursor: default; }

        .option-letter {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            flex-shrink: 0;
        }

        .option-btn.correct .option-letter {
            background: var(--correct);
            color: white;
        }

        .option-btn.incorrect .option-letter {
            background: var(--incorrect);
            color: white;
        }

        .option-text { flex: 1; }

        .feedback {
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .feedback.show { display: block; }
        .feedback.correct { background: var(--correct-bg); color: #166534; }
        .feedback.incorrect { background: var(--incorrect-bg); color: #991b1b; }

        /* Results */
        .results-card {
            background: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 32px;
            text-align: center;
            max-width: 500px;
            margin: 40px auto;
            display: none;
        }
        .results-card.show { display: block; }
        .results-icon { font-size: 48px; margin-bottom: 8px; }
        .results-score { font-size: 36px; font-weight: 700; color: var(--quiz-accent); }
        .results-label { font-size: 14px; color: var(--text-secondary); margin-bottom: 16px; }
        .results-grade {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .grade-a { background: #dcfce7; color: #166534; }
        .grade-b { background: #dbeafe; color: #1e40af; }
        .grade-c { background: #fef3c7; color: #92400e; }
        .grade-d { background: #fed7aa; color: #9a3412; }
        .grade-f { background: #fee2e2; color: #991b1b; }

        .results-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            text-decoration: none;
        }
        .btn-primary { background: var(--quiz-accent); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 1px solid var(--border); }

        /* Next button container */
        .next-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-next {
            padding: 10px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            background: var(--quiz-accent);
            color: white;
            transition: all 0.2s;
            display: none;
        }
        .btn-next:hover { background: #7c3aed; transform: scale(1.02); }
        .btn-next.show { display: inline-block; }
        .btn-next:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 900px) {
            .questions-row { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 600px) {
            .questions-row { grid-template-columns: 1fr; }
            .question-card { min-height: auto; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">Quiz 6: Embeddings & RL</div>
        <div class="nav-links">
            <a href="../index.html">Dashboard</a>
            <a href="https://github.com/Digital-AI-Finance/methods-algorithms" target="_blank">GitHub</a>
        </div>
    </nav>

    <main class="quiz-container">
        <div class="quiz-header">
            <div class="quiz-title">Quiz 6: Embeddings & RL</div>
            <div class="quiz-stats">
                <span class="stat-badge stat-progress" id="progressBadge">0/20</span>
                <span class="stat-badge stat-score" id="scoreBadge">Score: 0</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <div class="questions-row" id="questionsRow"></div>

        <div class="next-btn-container">
            <button class="btn-next" id="nextBtn" onclick="loadNextQuestions()">Next</button>
        </div>

        <div class="results-card" id="resultsCard">
            <div class="results-icon" id="resultsIcon"></div>
            <div class="results-score" id="resultsScore"></div>
            <div class="results-label">Correct Answers</div>
            <div class="results-grade" id="resultsGrade"></div>
            <div class="results-buttons">
                <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
                <a href="../index.html" class="btn btn-secondary">Dashboard</a>
            </div>
        </div>
    </main>

    <script>
        const quizData = {
            questions: [
                {
                    "id": 1,
                    "question": "What is a major limitation of one-hot encoding for words?",
                    "options": {
                        "A": "It captures semantic similarity between words",
                        "B": "Vectors are sparse with dimensionality equal to vocabulary size",
                        "C": "It requires labeled training data",
                        "D": "It only works for numerical features"
                    },
                    "correct": "B",
                    "explanation": "One-hot encoding creates sparse vectors where each word is represented by a vector of length V (vocabulary size) with a single 1 and all other entries 0. This is memory-inefficient and doesn't capture word relationships."
                },
                {
                    "id": 2,
                    "question": "What is the key advantage of dense word embeddings over one-hot encoding?",
                    "options": {
                        "A": "They use more memory",
                        "B": "They capture semantic relationships in low-dimensional space",
                        "C": "They are easier to interpret",
                        "D": "They require no training"
                    },
                    "correct": "B",
                    "explanation": "Dense embeddings represent words in low-dimensional continuous vectors (e.g., 100-300 dimensions) where similar words are close together, capturing semantic relationships that one-hot encoding cannot."
                },
                {
                    "id": 3,
                    "question": "The distributional hypothesis states that words with similar meanings:",
                    "options": {
                        "A": "Have the same spelling",
                        "B": "Appear in similar contexts",
                        "C": "Have the same length",
                        "D": "Start with the same letter"
                    },
                    "correct": "B",
                    "explanation": "The distributional hypothesis, often summarized as 'you shall know a word by the company it keeps' (Firth, 1957), states that words occurring in similar contexts tend to have similar meanings."
                },
                {
                    "id": 4,
                    "question": "In Word2Vec Skip-gram, what does the model predict?",
                    "options": {
                        "A": "The center word given context words",
                        "B": "Context words given the center word",
                        "C": "The next sentence",
                        "D": "Word frequency"
                    },
                    "correct": "B",
                    "explanation": "Skip-gram predicts surrounding context words given the center word. For example, given 'bank', it learns to predict 'river', 'money', 'account' based on training contexts."
                },
                {
                    "id": 5,
                    "question": "How does CBOW differ from Skip-gram?",
                    "options": {
                        "A": "CBOW predicts the center word from context; Skip-gram predicts context from center",
                        "B": "CBOW is slower to train",
                        "C": "CBOW works better for rare words",
                        "D": "CBOW uses character-level features"
                    },
                    "correct": "A",
                    "explanation": "CBOW (Continuous Bag of Words) predicts the center word given surrounding context words, while Skip-gram does the reverse. CBOW is faster to train but Skip-gram performs better on rare words."
                },
                {
                    "id": 6,
                    "question": "The word analogy 'king - man + woman = queen' demonstrates that embeddings capture:",
                    "options": {
                        "A": "Word frequency",
                        "B": "Semantic relationships as vector arithmetic",
                        "C": "Grammar rules",
                        "D": "Sentence structure"
                    },
                    "correct": "B",
                    "explanation": "Word analogies show that embeddings encode semantic relationships as directions in vector space. The vector from 'man' to 'woman' is similar to 'king' to 'queen', allowing vector arithmetic to solve analogies."
                },
                {
                    "id": 7,
                    "question": "What is the cosine similarity between vectors $[1, 0]$ and $[0, 1]$?",
                    "options": {
                        "A": "1",
                        "B": "0",
                        "C": "-1",
                        "D": "0.5"
                    },
                    "correct": "B",
                    "explanation": "Cosine similarity = $\\frac{a \\cdot b}{||a|| \\cdot ||b||} = \\frac{1 \\times 0 + 0 \\times 1}{1 \\times 1} = 0$. Perpendicular (orthogonal) vectors have zero cosine similarity, indicating no relationship."
                },
                {
                    "id": 8,
                    "question": "What is the cosine similarity between a vector and itself?",
                    "options": {
                        "A": "0",
                        "B": "The vector's magnitude",
                        "C": "1",
                        "D": "Undefined"
                    },
                    "correct": "C",
                    "explanation": "For any non-zero vector $a$, cosine similarity with itself is $\\frac{a \\cdot a}{||a|| \\cdot ||a||} = \\frac{||a||^2}{||a||^2} = 1$. This is the maximum possible similarity."
                },
                {
                    "id": 9,
                    "question": "Which pre-trained embedding model uses character n-grams to handle out-of-vocabulary words?",
                    "options": {
                        "A": "Word2Vec",
                        "B": "GloVe",
                        "C": "FastText",
                        "D": "BERT"
                    },
                    "correct": "C",
                    "explanation": "FastText represents words as sums of character n-gram embeddings. This allows it to generate embeddings for unseen words by combining known n-grams, handling typos and morphological variations."
                },
                {
                    "id": 10,
                    "question": "Why might FinBERT be preferred over general BERT for financial sentiment analysis?",
                    "options": {
                        "A": "It runs faster",
                        "B": "It was fine-tuned on financial text and understands domain-specific language",
                        "C": "It uses smaller embeddings",
                        "D": "It doesn't require GPU"
                    },
                    "correct": "B",
                    "explanation": "FinBERT is fine-tuned on financial news and reports, understanding that 'bullish' means positive sentiment and 'short' can mean a trading position. Domain-specific models capture nuances that general models miss."
                },
                {
                    "id": 11,
                    "question": "In a Markov Decision Process (MDP), what does the tuple $(S, A, P, R, \\gamma)$ represent?",
                    "options": {
                        "A": "Speed, Accuracy, Precision, Recall, Gradient",
                        "B": "States, Actions, Transition probabilities, Rewards, Discount factor",
                        "C": "Samples, Attributes, Probabilities, Results, Gain",
                        "D": "Sequences, Algorithms, Parameters, Regularization, Growth"
                    },
                    "correct": "B",
                    "explanation": "An MDP is defined by: States (S) - possible situations; Actions (A) - possible moves; P - transition probabilities; R - reward function; and $\\gamma$ - discount factor for future rewards."
                },
                {
                    "id": 12,
                    "question": "The Markov property states that:",
                    "options": {
                        "A": "All states are equally likely",
                        "B": "The future depends only on the current state, not the history",
                        "C": "Rewards must be positive",
                        "D": "Actions must be deterministic"
                    },
                    "correct": "B",
                    "explanation": "The Markov property means $P(s_{t+1}|s_t, s_{t-1}, ..., s_0) = P(s_{t+1}|s_t)$. The current state contains all information needed to predict the future; history doesn't matter."
                },
                {
                    "id": 13,
                    "question": "A policy $\\pi(a|s)$ represents:",
                    "options": {
                        "A": "The reward for action $a$ in state $s$",
                        "B": "The probability of taking action $a$ in state $s$",
                        "C": "The next state after taking action $a$",
                        "D": "The value of state $s$"
                    },
                    "correct": "B",
                    "explanation": "A policy $\\pi(a|s)$ is a mapping from states to action probabilities. It defines the agent's behavior by specifying the probability of selecting each action in each state."
                },
                {
                    "id": 14,
                    "question": "What does the Q-function $Q(s, a)$ represent?",
                    "options": {
                        "A": "The immediate reward for action $a$ in state $s$",
                        "B": "The expected cumulative reward starting from state $s$, taking action $a$, then following the optimal policy",
                        "C": "The probability of reaching state $s$",
                        "D": "The quality of the training data"
                    },
                    "correct": "B",
                    "explanation": "The Q-function (action-value function) estimates the expected total discounted reward when taking action $a$ in state $s$ and then following the optimal policy. It guides action selection."
                },
                {
                    "id": 15,
                    "question": "The Bellman equation for $Q^*(s, a)$ states that optimal Q-values satisfy:",
                    "options": {
                        "A": "$Q^*(s, a) = R(s, a)$",
                        "B": "$Q^*(s, a) = R(s, a) + \\gamma \\max_{a'} Q^*(s', a')$",
                        "C": "$Q^*(s, a) = \\gamma Q^*(s', a')$",
                        "D": "$Q^*(s, a) = \\sum_a Q^*(s, a)$"
                    },
                    "correct": "B",
                    "explanation": "The Bellman optimality equation decomposes the Q-value into immediate reward plus discounted future value: $Q^*(s, a) = R(s, a) + \\gamma \\max_{a'} Q^*(s', a')$. This recursion enables iterative computation."
                },
                {
                    "id": 16,
                    "question": "In Q-learning, how is the Q-table updated after observing reward $r$ and next state $s'$?",
                    "options": {
                        "A": "$Q(s, a) \\leftarrow r$",
                        "B": "$Q(s, a) \\leftarrow Q(s, a) + \\alpha[r + \\gamma \\max_{a'} Q(s', a') - Q(s, a)]$",
                        "C": "$Q(s, a) \\leftarrow \\max Q(s', a')$",
                        "D": "$Q(s, a) \\leftarrow Q(s, a) + r$"
                    },
                    "correct": "B",
                    "explanation": "Q-learning uses temporal difference: update $Q(s,a)$ toward target $r + \\gamma \\max_{a'} Q(s', a')$ with learning rate $\\alpha$. This incrementally improves Q-estimates from experience."
                },
                {
                    "id": 17,
                    "question": "The exploration-exploitation tradeoff in RL refers to balancing:",
                    "options": {
                        "A": "Training speed vs. accuracy",
                        "B": "Trying new actions vs. using known good actions",
                        "C": "Memory usage vs. computation",
                        "D": "Model complexity vs. interpretability"
                    },
                    "correct": "B",
                    "explanation": "Exploration means trying new actions to discover potentially better strategies. Exploitation means using the best known action. Balancing both is essential: too much exploration wastes time, too little may miss optimal solutions."
                },
                {
                    "id": 18,
                    "question": "In an $\\varepsilon$-greedy strategy with $\\varepsilon = 0.1$, what happens?",
                    "options": {
                        "A": "Random action 100% of the time",
                        "B": "Best known action 10% of the time, random 90%",
                        "C": "Best known action 90% of the time, random 10%",
                        "D": "Best known action 100% of the time"
                    },
                    "correct": "C",
                    "explanation": "With $\\varepsilon$-greedy, the agent takes the action with highest Q-value with probability $1-\\varepsilon$ (90%) and a random action with probability $\\varepsilon$ (10%). This ensures exploration while mostly exploiting."
                },
                {
                    "id": 19,
                    "question": "A discount factor $\\gamma = 0.9$ means the agent:",
                    "options": {
                        "A": "Ignores future rewards entirely",
                        "B": "Values immediate and future rewards equally",
                        "C": "Values future rewards but prefers sooner rewards",
                        "D": "Only considers the final reward"
                    },
                    "correct": "C",
                    "explanation": "With $\\gamma = 0.9$, a reward $r$ received $k$ steps in the future contributes $0.9^k \\cdot r$ to the total. The agent values future rewards but discounts them, preferring sooner payoffs. $\\gamma = 1$ would weight all equally."
                },
                {
                    "id": 20,
                    "question": "Deep Q-Networks (DQN) improve on tabular Q-learning by:",
                    "options": {
                        "A": "Using a neural network to approximate Q-values for large/continuous state spaces",
                        "B": "Removing the need for rewards",
                        "C": "Eliminating exploration",
                        "D": "Only working with discrete actions"
                    },
                    "correct": "A",
                    "explanation": "DQN uses a neural network to approximate $Q(s, a)$ instead of a lookup table. This enables RL in environments with large or continuous state spaces (like images) where a table would be infeasible."
                }
            ]
        };

        const state = {
            currentIndex: 0,
            answers: {},
            score: 0,
            displayedQuestions: [],
            pendingSlots: []
        };

        const questionsRow = document.getElementById('questionsRow');
        const progressBar = document.getElementById('progressBar');
        const progressBadge = document.getElementById('progressBadge');
        const scoreBadge = document.getElementById('scoreBadge');
        const resultsCard = document.getElementById('resultsCard');
        const nextBtn = document.getElementById('nextBtn');

        function initQuiz() {
            state.currentIndex = 0;
            state.answers = {};
            state.score = 0;
            state.displayedQuestions = [];
            state.pendingSlots = [];

            resultsCard.classList.remove('show');
            questionsRow.style.display = 'grid';
            nextBtn.classList.remove('show');

            // Show first 3 questions
            for (let i = 0; i < 3 && i < quizData.questions.length; i++) {
                state.displayedQuestions.push(i);
            }
            state.currentIndex = Math.min(3, quizData.questions.length);

            renderQuestions();
            updateStats();
        }

        function renderQuestions() {
            questionsRow.innerHTML = '';

            state.displayedQuestions.forEach((qIdx, slot) => {
                const q = quizData.questions[qIdx];
                const answered = state.answers[q.id] !== undefined;
                const isCorrect = answered && state.answers[q.id] === q.correct;
                const isIncorrect = answered && state.answers[q.id] !== q.correct;

                const card = document.createElement('div');
                card.className = 'question-card';
                if (isCorrect) card.classList.add('correct-card', 'answered');
                if (isIncorrect) card.classList.add('incorrect-card', 'answered');

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-number">Q${qIdx + 1}</span>
                        ${answered ? `<span class="q-status">${isCorrect ? '&#10004;' : '&#10008;'}</span>` : ''}
                    </div>
                    <div class="q-text">${q.question}</div>
                    <div class="options" data-qid="${q.id}" data-slot="${slot}">
                        ${['A','B','C','D'].map(letter => {
                            let optClass = 'option-btn';
                            if (answered) {
                                optClass += ' disabled';
                                if (letter === q.correct) optClass += ' correct';
                                else if (letter === state.answers[q.id]) optClass += ' incorrect';
                            }
                            return `
                                <button class="${optClass}" data-letter="${letter}" ${answered ? 'disabled' : ''}>
                                    <span class="option-letter">${letter}</span>
                                    <span class="option-text">${q.options[letter]}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>
                    <div class="feedback ${answered ? 'show' : ''} ${isCorrect ? 'correct' : 'incorrect'}">
                        ${answered ? (isCorrect ? '&#10004; ' : `&#10008; Answer: ${q.correct}. `) + q.explanation : ''}
                    </div>
                `;

                // Add click handlers
                if (!answered) {
                    card.querySelectorAll('.option-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(qIdx, slot, btn.dataset.letter));
                    });
                }

                questionsRow.appendChild(card);
            });

            renderMath();
        }

        function handleAnswer(qIdx, slot, letter) {
            const q = quizData.questions[qIdx];
            state.answers[q.id] = letter;

            if (letter === q.correct) state.score++;

            // Track this slot as pending replacement
            if (!state.pendingSlots.includes(slot)) {
                state.pendingSlots.push(slot);
            }

            updateStats();
            renderQuestions();

            // Check if all questions answered
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                // Short delay then show results
                setTimeout(showResults, 800);
            } else if (state.currentIndex < quizData.questions.length && state.pendingSlots.length > 0) {
                // Show Next button if there are more questions and pending slots
                nextBtn.classList.add('show');
            }
        }

        function loadNextQuestions() {
            // Replace pending slots with new questions
            while (state.pendingSlots.length > 0 && state.currentIndex < quizData.questions.length) {
                const slot = state.pendingSlots.shift();
                state.displayedQuestions[slot] = state.currentIndex;
                state.currentIndex++;
            }

            // Hide Next button
            nextBtn.classList.remove('show');

            renderQuestions();

            // Check if quiz is complete (all displayed questions answered)
            const answered = Object.keys(state.answers).length;
            if (answered >= quizData.questions.length) {
                setTimeout(showResults, 500);
            }
        }

        function updateStats() {
            const answered = Object.keys(state.answers).length;
            const total = quizData.questions.length;

            progressBar.style.width = `${(answered / total) * 100}%`;
            progressBadge.textContent = `${answered}/${total}`;
            scoreBadge.textContent = `Score: ${state.score}`;
        }

        function showResults() {
            questionsRow.style.display = 'none';
            nextBtn.classList.remove('show');
            resultsCard.classList.add('show');

            const total = quizData.questions.length;
            const percentage = Math.round((state.score / total) * 100);

            document.getElementById('resultsScore').textContent = `${state.score}/${total}`;

            let grade, gradeClass, icon;
            if (percentage >= 90) { grade = 'Excellent! A'; gradeClass = 'grade-a'; icon = '&#127942;'; }
            else if (percentage >= 80) { grade = 'Great! B'; gradeClass = 'grade-b'; icon = '&#11088;'; }
            else if (percentage >= 70) { grade = 'Good! C'; gradeClass = 'grade-c'; icon = '&#128077;'; }
            else if (percentage >= 60) { grade = 'Pass - D'; gradeClass = 'grade-d'; icon = '&#128221;'; }
            else { grade = 'Keep practicing'; gradeClass = 'grade-f'; icon = '&#128218;'; }

            document.getElementById('resultsIcon').innerHTML = icon;
            const gradeEl = document.getElementById('resultsGrade');
            gradeEl.textContent = `${grade} (${percentage}%)`;
            gradeEl.className = `results-grade ${gradeClass}`;
        }

        function restartQuiz() {
            initQuiz();
        }

        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                const opts = {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                };
                // Render only quiz content elements â€” avoids cross-element
                // delimiter pairing when renderMathInElement scans document.body
                document.querySelectorAll('.q-text, .option-text, .feedback').forEach(el => {
                    renderMathInElement(el, opts);
                });
            }
        }

        function waitForKaTeX(callback, maxAttempts = 50) {
    let attempts = 0;
    function check() {
        if (typeof renderMathInElement !== 'undefined') {
            callback();
        } else if (attempts < maxAttempts) {
            attempts++;
            setTimeout(check, 50);
        }
    }
    check();
}

// Initialize with error handling
        try {
            initQuiz();
            waitForKaTeX(renderMath);
        } catch (e) {
            console.error('Quiz initialization error:', e);
            const container = document.getElementById('questionsRow') || document.querySelector('.main');
            if (container) {
                container.innerHTML =
                    '<div style="padding:2rem;text-align:center;color:#991b1b;">' +
                    '<h3>Quiz failed to load</h3><p>Error: ' + e.message + '</p>' +
                    '<p>Please refresh the page or try a different browser.</p></div>';
            }
        }
    </script>
</body>
</html>
